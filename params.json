{"name":"Bomba","tagline":"A prototype Answer Set Programming Scala DSL.","body":"**bomba** - a prototype Answer Set Programming Scala DSL\r\n=====================================================================\r\n\r\nBomba is an [Answer Set Programming](https://en.wikipedia.org/wiki/Answer_set_programming) dialect in the form of a Scala DSL. It is intended, currently, as a prototype to experiment with possible syntax and semantic variants, as well as language integration.\r\n\r\nUsage\r\n----------\r\n\r\n 1. \r\n   - If your build system is m2-compatible:\r\n     1. `mvn clean install`\r\n     1. Add org.bomba_lang:bomba_lang to your dependencies.\r\n   - Otherwise:\r\n     1. `mvn clean package`\r\n \t   1. Add the resulting JAR to the build path of your project.\r\n 1. Add: `import org.bomba_lang.proto._` to your Scala import statements.\r\n 1. Add the `macro-paradise` compiler plugin to your Maven/SBT build - as described in [the macro documentation](http://docs.scala-lang.org/overviews/macros/paradise.html). \r\n\r\n\r\nSyntax\r\n-----------\r\nThe syntax is similar to other Answer Set Programming dialects.\r\n\r\nA **literal** is of the form\r\n\r\n```scala\r\nname(x1,...,xn)\r\n-name(x1,...,xn)\r\n```\r\n    \r\nwhere `n >= 0` (if `n=0`, the parenthesis are optional), and `x1,...,xn` are of the type `Any`. `-` means \"strong negation\".\r\n\r\nAn `xm` (`1 <= m <= n`) of type Symbol (e.g. 'X ), is a **variable**.\r\n\r\nA **rule** is of the form\r\n\r\n```scala\r\nhP1 v ... v hPl :- (bP1,...,bPm,~nbP1,...,~nbPn)\r\nhP1 ∨ ... ∨ hPl ⟵  bP1 ∧ ... ∧ bPm ∧ ~nbP1 ∧ ... ∧ ~nbPn\r\n```\r\n\r\nwhere `hP1,...,hPl, bP1,...,bPm, nbP1,...,nbPn` are literals. `~` means \"default negation\".\r\n\r\nA **program** is a Scala code block of the form\r\n\r\n```scala\r\n@bomba\r\nval progName = {\r\n\tr1\r\n\t...\r\n\trn\r\n}\r\n```\r\n  \r\nwhere `r1,...,rn` are rules. Note that:\r\n - the rules are treated as standard Scala expressions, i.e. they must be either in \r\nseparate lines, or separated with `;` when on the same line.\r\n - the names of the literals \"shadow\" any same-named `val`s and/or `def`s in the program's local scope.\r\n\r\n*Note: yes, this means you can use Unicode symbols for logical operators in your program!*\r\n\r\nSemantics\r\n------------\r\nSemantics depend on the solver used. The current reference implementation, `org.bomba_lang.proto.NaiveSolver`, uses standard\r\ndisjunctive semantics, with the Ferraris and Lifschitz resolution variant for strong negation. To generate all answer sets, use:\r\n\r\n```scala\r\nprogram.solve\r\n```\r\n\t\r\nThe idiomatic way of interfacing your logic programs with the rest of your code is to define your \"oracle\" program, and then inject\r\nthe data you wish to provide in the solve method, e.g.:\r\n\r\n```scala\r\n@bomba\r\nval oracle = {...}\r\n@bomba\r\nval data = {...}\r\noracle.solve(data)\r\n```\r\n\t\r\nExamples\r\n-----------\r\n\r\nHere's the source from the main class of the [demo project](https://github.com/mikkoz/bomba-demo), to give you an idea of the syntax and semantics:\r\n```scala\r\npackage org.bomba_lang.bomba_demo\r\n\r\nimport org.bomba_lang.proto._\r\n\r\nobject Demo {\r\n\r\n  def main(args: Array[String]): Unit = {\r\n\r\n    @bomba\r\n    val prog1 = { z(1, 2) }\r\n\r\n    println(prog1)\r\n\r\n    @bomba\r\n    val prog2 = {\r\n      y v z\r\n    }\r\n\r\n    println(prog2.solve)\r\n\r\n    @bomba\r\n    val prog3 = {\r\n      rain :- wet\r\n      wet\r\n    }\r\n\r\n    println(prog3.solve)\r\n\r\n    println(\"canonical program extension\")\r\n    @bomba\r\n    val r0 = {\r\n      rain :- wet\r\n    }\r\n    println(r0.solve)\r\n    @bomba\r\n    val r1 = {\r\n      wet\r\n    }\r\n    println(r0.solve(r1))\r\n    println(\"-------------------\")\r\n\r\n    println(\"canonical program extension with default negation\")\r\n    @bomba\r\n    val rn0 = {\r\n      rain :- wet & ~sprinkler\r\n    }\r\n    println(r0.solve)\r\n    @bomba\r\n    val rn1 = {\r\n      wet\r\n    }\r\n    println(rn0.solve(rn1))\r\n    @bomba\r\n    val rn2 = {\r\n      wet\r\n      sprinkler\r\n    }\r\n    println(rn0.solve(rn2))\r\n    println(\"-------------------\")\r\n\r\n    println(\"variables\")\r\n    @bomba\r\n    val varProg = {\r\n      x(1)\r\n      y(2)\r\n      z('X, 'Y) :- x('X) & y('Y)\r\n    }\r\n    println(\"Ungrounded: \" + varProg)\r\n\r\n    val varProgGround = new GroundProgram(varProg)\r\n    println(\"Grounded: \" + varProgGround)\r\n    println(\"Result: \" + varProgGround.solve)\r\n    println(\"-------------------\")\r\n\r\n    println(\"\\\"Formal\\\" notation\")\r\n    @bomba\r\n    val formalProg = {\r\n      a ∨ b ⟵ x ∧ y ∧ z\r\n    }\r\n    println(formalProg)\r\n\r\n  }\r\n\r\n}\r\n```\r\n\r\nComments? Issues?\r\n------------\r\nAll welcome.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}